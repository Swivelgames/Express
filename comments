// commented crap



// TODO: should look into making english-like inputs for the indentation
// TODO: add flags for verbosity, printouts, whether to not parse the tokens, output file for outputting tokens, output format (xml, json, native) etc
// TODO: check if the file exists and if it does warn them that the output file will be overridden and ask if they still want to go through
// func parseFlags() {
// 	jsonIndentPtr := flag.String("jsonIndent", "blank", "Indent that will be used for the JSON printout of the tokens")
// 	flag.Parse()

// 	fmt.Println("jsonptr", *jsonIndentPctr)

// 	// jsonIndent
// 	jsonIndent = *jsonIndentPtr
// }

// TODO: we need a `getNextNonWSToken`

// func getFactor(i int) bool {
// 	fmt.Println("getting factor")

// 	// FIXME: we should first add a check for parens
// 	// FIXME: this will only work for spaces between them; hence the +2
// 	fmt.Println(p.Tokens[i].Type)
// 	if p.Tokens[i].Type == "LITERAL" {
// 		fmt.Println("Found a literal")
// 		endTokens = append(endTokens, p.Tokens[i])
// 		return true
// 	}

// 	return false
// }

// func llvmConversion(endTokens []token.Token) {
// 	llFilename := p.Name + ".ll"

// 	// For more granular writes, open a file for writing.
// 	f, err := os.Create(llFilename)
// 	defer func() {
// 		if err = f.Close(); err != nil {
// 			fmt.Println("ERROR: Could not close file:", llFilename)
// 		}
// 	}()
// 	if err != nil {
// 		fmt.Println("ERROR: Could not open token output file:", llFilename)
// 		os.Exit(9)
// 	}
// 	w := bufio.NewWriter(f)

// 	llvmInstructionString := ""

// 	// TODO: this needs to be outputted as program.expr.parse
// 	for i := 0; i < len(endTokens); i++ {
// 		t := endTokens[i]

// 		switch t.Type {
// 		case "TYPE":
// 			switch t.Value.String {
// 			case "int":
// 				// TODO: see if the variable declaration is something we already have
// 				llvmInstructionString += "%1 = alloca i32, align 4\n"
// 				// TODO: default value will force-find the next literal
// 			}
// 		case "LITERAL":
// 			llvmInstructionString += "store i32 " + t.Value.String + ", i32* %1, align 4"
// 		}

// 		// if t.Value.String == "int" {
// 		// 	llvmInstructionString += "%1 = alloca i32, align 4\n"
// 		// } else if t.Value.Type == "integer" {
// 		// 	llvmInstructionString += "store i32 5, i32* %1, align 4\n"
// 		// }
// 	}

// 	_, err = w.WriteString(llvmStart)
// 	if err != nil {
// 		fmt.Println("omggg!!!1")
// 		return
// 	}

// 	_, err = w.WriteString(llvmInstructionString + "\n")
// 	if err != nil {
// 		fmt.Println("omggg!!!2")
// 		return
// 	}

// 	_, err = w.WriteString(llvmEnd)
// 	if err != nil {
// 		fmt.Println("omggg!!!4")
// 		return
// 	}

// 	err = w.Flush()
// 	if err != nil {
// 		fmt.Println("ERROR: Could not flush writer, data may be missing:", llFilename)
// 	}
// }


// TODO: make this take a compile stage
// TODO: rename this function and redo all comments/printouts to reflect that
// func outputTokens() {
// 	lexFilename := p.Name + ".lex"

// 	// For more granular writes, open a file for writing.
// 	f, err := os.Create(lexFilename)
// 	defer func() {
// 		if err = f.Close(); err != nil {
// 			fmt.Println("ERROR: Could not close file:", lexFilename)
// 		}
// 	}()
// 	if err != nil {
// 		fmt.Println("ERROR: Could not open token output file:", lexFilename)
// 		os.Exit(9)
// 	}
// 	w := bufio.NewWriter(f)

// 	fmt.Println()
// 	fmt.Println("Outputting tokens to:", lexFilename)

// 	var tokenJSON []byte
// 	if jsonIndent != "" {
// 		for index, token := range p.Tokens {
// 			tokenJSON, err = json.MarshalIndent(token, "", jsonIndent)
// 			if err != nil {
// 				fmt.Printf("\nERROR: Could not marshal JSON from token: %#v\n", token)
// 				os.Exit(9)
// 			}
// 			if index < len(p.Tokens)-1 {
// 				tokenJSON = append(tokenJSON, '\n')
// 			}
// 			// TODO: we should check the amount later
// 			_, err = w.Write(tokenJSON)
// 			if err != nil {
// 				fmt.Println("ERROR: Could not write to token output file:", lexFilename)
// 				os.Exit(9)
// 			}
// 		}
// 	} else {
// 		for index, token := range p.Tokens {
// 			tokenJSON, err = json.Marshal(token)
// 			if err != nil {
// 				fmt.Printf("\nERROR: Could not marshal JSON from token: %#v\n", token)
// 				os.Exit(9)
// 			}
// 			if index < len(p.Tokens)-1 {
// 				tokenJSON = append(tokenJSON, '\n')
// 			}
// 			_, err = w.Write(tokenJSON)
// 			if err != nil {
// 				fmt.Println("ERROR: Could not write to token output file:", lexFilename)
// 				os.Exit(9)
// 			}
// 		}
// 	}

// 	err = w.Flush()
// 	if err != nil {
// 		fmt.Println("ERROR: Could not flush writer, data may be missing:", lexFilename)
// 	}
// }